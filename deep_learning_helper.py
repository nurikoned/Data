# -*- coding: utf-8 -*-
"""Deep_Learning_Helper.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kd4jD1wsitk7Ztbp-6KAHXoTmhCyLs2o

# **FUNCTION TO PLOT LOSS CURVES**
"""

import matplotlib.pyplot as plt
def plot_loss_curves(history):
  loss = history.history['loss']
  val_loss = history.history['val_loss']
  accuracy = history.history['accuracy']
  val_accuracy = history.history['val_accuracy']

  epochs = range(len(history.history['loss']))

  plt.plot(epochs, loss, label='training_loss')
  plt.plot(epochs, val_loss, label='val_loss')
  plt.title('Loss')
  plt.xlabel('Epochs')
  plt.legend()

  plt.figure()
  plt.plot(epochs, accuracy, label='training_accuracy')
  plt.plot(epochs, val_accuracy, label='val_accuracy')
  plt.title('Accuracy')
  plt.xlabel('Epochs')
  plt.legend()

"""# **FUNCTION TO CREATE TL MODEL**"""

IMAGE_SHAPE = (224,224)
from tensorflow.keras import layers
import tensorflow_hub as hub
import tf_keras as keras
def create_model(model_url, num_classes=10):
  # Download the pretrained model and save it as a Keras layer
  feature_extractor_layer = hub.KerasLayer(model_url,
                                           trainable=False, # freeze the underlying patterns
                                           name='feature_extraction_layer',
                                           input_shape=IMAGE_SHAPE+(3,)) # define the input image shape

  # Create our own model
  model = keras.Sequential([
    feature_extractor_layer, # use the feature extraction layer as the base
    keras.layers.Dense(num_classes, activation='softmax', name='output_layer') # create our own output layer
  ])

  return model

"""# **FUNCTION TO PLOT RANDOM IMAGE ON CNN**"""

import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import random

def view_random_image(target_dir, target_class):
  target_folder = target_dir + target_class
  random_image = random.sample(os.listdir(target_folder), 1)
  print(random_image)

  img = mpimg.imread(target_folder + "/" + random_image[0])
  plt.imshow(img)
  plt.title(target_class)
  plt.axis("off")

  print(f"Image shape: {img.shape}")

  return img

"""# **MAKE CONFUSION MATRIX**"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import ConfusionMatrixDisplay, confusion_matrix
import tensorflow as tf  # Ensure you have TensorFlow imported for tf.round()

def plot_confusion_matrix(y_true, y_pred, normalize=True, figsize=(10, 10), cmap='Blues', title="Confusion Matrix"):
    """
    Plots a confusion matrix for the given true and predicted labels.

    Args:
    - y_true: Ground truth labels.
    - y_pred: Predicted labels.
    - normalize: Whether to normalize the confusion matrix (default=True).
    - figsize: Tuple for figure size (default=(10, 10)).
    - cmap: Colormap for the matrix (default='Blues').
    - title: Title for the plot (default="Confusion Matrix").
    """
    # Create confusion matrix
    cm = confusion_matrix(y_true, tf.round(y_pred))

    # Normalize the confusion matrix if requested
    if normalize:
        cm = cm.astype("float") / cm.sum(axis=1)[:, np.newaxis]

    # Plot confusion matrix
    disp = ConfusionMatrixDisplay(confusion_matrix=cm)
    plt.figure(figsize=figsize)
    disp.plot(cmap=cmap, values_format=".2f" if normalize else "d")  # Formatting numbers
    plt.title(title)
    plt.show()

# Example usage:
# plot_confusion_matrix(y_test, y_preds, normalize=True)